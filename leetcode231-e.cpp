/*方法一：二进制表示
思路与算法

一个数 nn 是 22 的幂，当且仅当 nn 是正整数，并且 nn 的二进制表示中仅包含 11 个 11。

因此我们可以考虑使用位运算，将 nn 的二进制表示中最低位的那个 11 提取出来，再判断剩余的数值是否为 00 即可。下面介绍两种常见的与「二进制表示中最低位」相关的位运算技巧。

第一个技巧是

\texttt{n \& (n - 1)}
n & (n - 1)

其中 \texttt{\&}& 表示按位与运算。该位运算技巧可以直接将 nn 二进制表示的最低位 11 移除，它的原理如下：

假设 nn 的二进制表示为 (a 10\cdots 0)_2(a10⋯0) 
2
​
 ，其中 aa 表示若干个高位，11 表示最低位的那个 11，0\cdots 00⋯0 表示后面的若干个 00，那么 n-1n−1 的二进制表示为：

(a 01\cdots1)_2
(a01⋯1) 
2
​
 

我们将 (a 10\cdots 0)_2(a10⋯0) 
2
​
  与 (a 01\cdots1)_2(a01⋯1) 
2
​
  进行按位与运算，高位 aa 不变，在这之后的所有位都会变为 00，这样我们就将最低位的那个 11 移除了。

因此，如果 nn 是正整数并且 \texttt{n \& (n - 1) = 0}n & (n - 1) = 0，那么 nn 就是 22 的幂。

第二个技巧是

\texttt{n \& (-n)}
n & (-n)

其中 -n−n 是 nn 的相反数，是一个负数。该位运算技巧可以直接获取 nn 二进制表示的最低位的 11。

由于负数是按照补码规则在计算机中存储的，-n−n 的二进制表示为 nn 的二进制表示的每一位取反再加上 11，因此它的原理如下：

假设 nn 的二进制表示为 (a 10\cdots 0)_2(a10⋯0) 
2
​
 ，其中 aa 表示若干个高位，11 表示最低位的那个 11，0\cdots 00⋯0 表示后面的若干个 00，那么 -n−n 的二进制表示为：

(\bar{a} 01\cdots1)_2 + (1)_2 = (\bar{a} 10\cdots0)_2
( 
a
ˉ
 01⋯1) 
2
​
 +(1) 
2
​
 =( 
a
ˉ
 10⋯0) 
2
​
 

其中 \bar{a} 
a
ˉ
  表示将 aa 每一位取反。我们将 (a 10\cdots 0)_2(a10⋯0) 
2
​
  与 (\bar{a} 10\cdots0)_2( 
a
ˉ
 10⋯0) 
2
​
  进行按位与运算，高位全部变为 00，最低位的 11 以及之后的所有 00 不变，这样我们就获取了 nn 二进制表示的最低位的 11。

因此，如果 nn 是正整数并且 \texttt{n \& (-n) = n}n & (-n) = n，那么 nn 就是 22 的幂。

代码

下面分别给出两种位运算技巧对应的代码。
在一些语言中，位运算的优先级较低，需要注意运算顺序。
*/

/*class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
};
*/

/*class Solution {
public:
    bool isPowerOfTwo(int n) {
        return n > 0 && (n & -n) == n;
    }
};

*/